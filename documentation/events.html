<h1 style="background:url(../img/hero/usersguide.jpg) no-repeat 0 10px">
	jQuery Tools Users Guide - Common practices for every tool
</h1>

<h2 class="first">Events</h2>

<p>
	Every tool is firing <em>events</em>. These are points in time where something critical happens on the tool. For example scrollable fires <samp>onSeek</samp> event every time a scrolling occurs. You can supply your own <em>event listeners</em> that are called every time an event occurs. These event listeners are normal JavaScript functions and are the most typical and effective way of extending the tools' behaviour. Event listeners are sometimes called <em>callback functions</em> and both are valid terms. 
</p>

<h3>Before and after events</h3>

<p>
	These tools provide both the <samp>onBefore</samp> event which occurs before some action is taken and the on event that occurs by the time (or after) an action takes place. You can have custom functionality bound to these events. All tools provide such events and they share a common naming policy. The <samp>onBefore</samp> event provides you with the possibility of cancelling the action. 
</p>
	

<h3>Example</h3>

<p>
	This example demonstrates the <samp>onBeforeClick</samp> callback function for Tabs
</p>

<pii:code>
$("#example").tabs(".panes > div", {

	// here is a "normal" configuration variable
	current: 'active,

	// here is a callback function that is called before the tab is clicked
	onBeforeClick: function(event, tabIndex) {

		// the "this variable is a pointer to the API. You can do a lot with it.
		var tabPanes = this.getPanes();

		/*
			By returning false here the default behaviour is cancelled.
			This time another tab cannot be clicked when "terms" are not accepted
		*/
		return $(":checkbox[name=terms]").is(":checked");
	}

});
</pii:code>


<h3>Supplying Events</h3>
	
<p>
	There are three different ways of supplying event listeners. 
</p>		

<h4>1. On configuration</h4>
	
<p>
	You can supply your event listeners direcly on the configuration when the tool is initialized. For example
</p>

<pii:code>
$(".tabs").tabs({

	// do your own stuff here
	onClick: function() {
	
		// "this" is a reference to the Tabs API
		var tabPanes = this.getPanes();
		
	}
});
</pii:code>

<p>
	This is the most common way to supply callbacks and is suitable for most of the situations. The biggest drawback in this method is that you ca supply only one callback for the same event. You cannot for example supply two different <samp>onClick</samp> event listeners on the configuration. 
</p>

<p>
	In the above example <samp>this</samp>- variable is a reference to the <a href="/tools/tabs/index.html#api">Tabs API</a>.
</p>

<h4>2. Using jQuery's <em>bind</em> method</h4>

<p>
	This is a standard way of assigning callback methods in jQuery land. Here is an example: 
</p>
	
<pii:code>
// first callback
$(".tabs").bind("onClick", function() {

	// "this" is a reference to the DOM element
	var ulElement = this;
	
// another one
}).bind("onClick", function() {
	
});
</pii:code>

<p>
	The <samp>bind</samp> method can be called multiple times so that you can assign multiple <samp>onClick</samp> listeners for example. This is crucial when developing jQuery Tools plugins.
</p>

<p>
	By using the <samp>bind</samp> method you can use the whole event binding arsenal that jQuery provides such as <a href="http://api.jquery.com/unbind" class="external">unbind</a> for removing event listeners and <a href="http://api.jquery.com/one" class="external">one</a> for calling your listener only once. The jQuery documentation for the <a href="http://api.jquery.com/bind" class="external">bind</a> method is a good reading and describes you the basics of event binding. It also talks about andvanced topics such as namespacing which are also valid in jQuery Tools. 
</p>	
	

<p>
	Inside your event listener <samp>this</samp>- variable is a reference to the DOM element returned by the jQuery selector just like jQuery programmers are accustomed to. 
</p>

<p>
	By far the best thing about <samp>bind</samp> method is that you can bind the same event listener to multiple instances with the same call. If for example the selector <samp>.tabs</samp> on our above example returns multiple instances the <samp>bind</samp> method will assign the listener to all instances simultaneously. Also note that <samp>bind</samp> allows you to supply multiple events types with the same call. For example
</p>

<pii:code>
// the same event listener is called before *and* after a tab is clicked
$(".tabs").bind("onBeforeClick onClick", function() {
	
});
</pii:code>

<h4>3. Supplying listeners from API</h4>

<p>
	Each jQuery Tool allows you to supply the event listeners from the API. For example  
</p>

<pii:code>
// grab the API with jQuery's data method
var api = $(".tabs").data("tabs");

// supply event listner
api.onBeforeClick(function()  {
	
// supply another
}).onClick(function() {
	
});
</pii:code>

<p>
	Inside the event listner <samp>this</samp>- variable is a reference to the Tools API and you can chain the methods "normally". This syntax follows more traditional programming style that is more fluent and understandable for people outside jQuery community. 
</p>
	
<pii:code>
// loop trough the instances
$(".tabs").each(function() {

	// assign onClick listener to a single instance
	$(this).data("tabs").onClick(function() {
		
	});
	
});
</pii:code>


<a name="object"></a>
<a name="event_object"></a>
<h3>The Event object</h3>

<p>
	Every callback function receives the <a href="http://api.jquery.com/category/events/event-object/" class="external">jQuery.Event</a> object as the first argument for the callback function. This event object standardizes the event processing according to the <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow-cancelation" class="external">W3C standards</a>. Here are some things you can do with this object:
</p>

<pii:code>
// the event object is the first argument for *all* callbacks in jQuery Tools
api.onClick(function(event) {

	// cancel the default action. same as returning false
	event.preventDefault();

	/* If you have multiple callbacks of the same type this prevents
		the rest of the callbacks from being executed. */
	event.stopImmediatePropagation();

	// retrieve the value returned by the previous callback function
	event.result;

	// The timestamp (in milliseconds) of when the event was created.
	event.timeStamp;

	// mouse position when event was fired
	var x = event.pageX;
	var y = event.pageY;

	// whether CTRL, ALT, SHIFT or ESC was being pressed
	var alt = event.altKey,
		 ctrl = event.ctrlKey,
		 shift = event.shiftMey,
		 esc = event.metaKey;


	// the original triggering element
	var element = e.originalTarget || e.srcElement;
});
</pii:code>

<p>
 	Within the scope of jQuery Tools, the <samp>preventDefault()</samp> is identical to returning <samp>false</samp> from the callback. This is just a matter of style where the <samp>preventDefault()</samp> is the modern manner of cancelling.
</p>

<p>
	You can get the handle to the actual element that fired the event with <samp>var element = e.originalTarget || e.srcElement;</samp>. For example, you can get a handle to the scrollable navigator item that was clicked inside the <samp>onSeek</samp> event.
</p>

<h3>A quick comparison with class-based inheritance</h3>

<p>
	Some programmers may argue that a better solution would have been to implement "classes" that users can "extend". Trust me, it's not. JavaScript is an inherently functional language, not an object-oriented one. Trying to mimic classical inherintance leads to poor design and makes programs longer and harder to understand. This is especially important in jQuery development because this library itself is highly dependent on callbacks and does not support any kind of inheritance. Functions are an easy, light-weight and effective way of extending behavior. Even newcomers can use them without understanding the anatomy of the JavaScript language.
</p>

