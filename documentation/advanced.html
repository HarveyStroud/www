
<script>
$(function() {
	$("#content h2:gt(0)").each(function(i) {
		$(this).prepend(i + 1 + ". ");
	});
});
</script>

<h1 style="background:url(../img/hero/usersguide.jpg) no-repeat 0 10px">
	jQuery Tools Users Guide - Common practices for each of the tools
</h1>


<!--{{{ API -->
<a name="api"></a>
<h2>Application Programming Interface <em>API</em></h2>

<p>
	Every tool has a well defined Application Programming Interface (API) that you can work with. This is one of the greatest strengths of this library. You can call tool methods and access their properties. The internal state is hidden and private variables are not accessible by the outer world which is what you would expect from good programming practice. Each tool behaves in a similar manner.
</p>

<p>
	The main goal for the API design is that there should be easy access to the tools API and at the same time each tool should behave like all other jQuery plugins do.
</p>

<h3>Getting the API upon initialization</h3>

<p>
	As seen above, when a tool is initialized, the return value is, by default, a jQuery object. This is what jQuery users are accustomed to and it should be respected. However, there must be an easy way of accessing the API upon construction and all tools supports an <samp>api</samp> property as follows:
</p>

<pii:code>
// create one scrollable element and return the API by enabling the "api" property
var api = $("#myDiv").scrollable({size: 3, api: true});
</pii:code>

<p>
	This is a very useful shortcut and provides quick access to the API. After you have the API available, you can start taking advantage of the powerful methods at your disposal. Here are a few examples:
</p>

<pii:code>
// we scroll two items forward
api.move(2);

// scroll to the beginning in 2000 milliseconds
api.begin(2000)

// do some custom actions when scrolling occurs
api.onSeek(function() {

	// inside callbacks the "this" variable is a reference to the API
	console.info("current position is: " + this.getIndex())
});
</pii:code>

<p>
	It is natural to have a tool-specific API available when working with a certain widget. There are no redundant methods and typically you won't need, for example, the DOM manipluation methods that jQuery offers. You will want to stick with the methods that relate to the task at hand.
</p>

<p>
	If you are using jQuery Tools plugins you need to supply the <samp>api</samp> parameter for the last plugin in the initialization chain. For example
</p>

<pii:code>
// when using plugins supply the api parameter for the last plugin
var api = $("#my_scrollable").scrollable().circular().mousewheel({api: true});
</pii:code>

<p>
	Every tool and plugin supports this <samp>api</samp> paramter.
</p>

<h3>Getting the API <em>after</em> initialization</h3>

<p>
	Another way of grabbing the API is by using the constructor <em>again</em> once the tool has been initialized. Here is an example:
</p>

<pii:code>
// grab the scrollable API after it has been initialized
var api = $("#myDiv").scrollable();
</pii:code>

<p>
	If you have multiple scrollable elements on your page and want to access a particular API, you can supply do it in one of the following ways:
</p>

<pii:code>
// return the third API from the list of scrollables using a numeric argument.
var api = $("div.scrollable").scrollable(2);

// alternate method is to use a jQuery selector
api = $("div.scrollable:eq(2)").scrollable();

// or like this, it is just a matter of taste
api = $("div.scrollable").eq(2).scrollable();
</pii:code>

<p>
	Note that the index argument is always zero-indexed, i.e., the first scrollable is located at <samp>scrollable(0)</samp>, the second at <samp>scrollabe(1)</samp>, etc.
</p>

<h3>Using the API</h3>

<p>
	After you have the API available, it behaves in a way that a "normal" programmer (or non-jQuery programmer) is accustomed to. There are getters, setters and methods that invoke actions. Invoking methods will always return the API itself so you can perform method chaining. For example:
</p>

<pii:code>
// normal API coding that programmers are accustomed to
var index = $("#example").tabs().click(1).getIndex();
</pii:code>

<p>
	Here the <samp>click</samp> method returns the API so you can continue with other tab methods such as <samp>getIndex</samp>. All tools support this kind of method chaining, just as you would expect from a jQuery plugin.
</p>

<p>
	In addition to normal methods, you also have the ability to register callback functions from the API which leads to the development of <em>jQuery Tools plugins</em>, but more about that later. Here is the <a href="scrollable.html#api">scrollable tools API</a> for you to study as an example.
</p>

<h3>jQuery UI compatibility</h3>

<p>
	If you are an active user of the jQuery UI library, you may want to get access to the API in a way that is compatible with that library. In jQuery UI, you can grab the API with the <samp>data</samp> method. This similar mechanism is fully supported by the Tools since its initial version. For example:
</p>

<pii:code>
// initialize tabs. a jQuery object is returned
var ul = $("ul.tabs").tabs();

// grab the API using data() method
var api = ul.data("tabs");
</pii:code>

<p>
	You can see that this is a bit more verbose than using the <samp>api</samp> property but this is still supported for your convenience.
</p>


<h3>jQuery UI <em>unified API</em></h3>

<p>
	jQuery UI has a so-called "unified API" which uses the following syntax for invoking methods:
</p>

<pii:code>
// call select method for tabs
$("ul.example").tabs("select", 1);
</pii:code>

<p>
	API methods are called by supplying the method name as a string followed by method arguments. This kind of syntax is <strong>not</strong> supported by the Tools. To be honest, I think that this kind API design is fundamentally wrong. It has the following problems:
</p>

<ol>
	<li>The syntax is unique to jQuery UI and people outside the UI community are not accustomed to it.</li>
	<li>
		The syntax is cubersome. For example, if you want to perform method chaining you have to write the following:
		<samp>$("ul.example").tabs("select", 1).tabs("disable", 2);</samp>
	</li>
	<li>
		The JavaScript engine cannot see typos. writing "selecct" does not produce any errors and makes it hard to debug.
	</li>
</ol>


<!--}}}-->


<!--{{{ Callbacks -->
<a name="callbacks"></a>
<h2>Using <em>Callback Functions</em></h2>

<p>
	These tools have extensive support for callback functions. These callbacks are functions that you supply in the configuration and which are called when something critical happens to the tool, such as an overlay is opened. Callback functions are your way to customize and extend the default behaviour of each tool.
</p>

<p>
	When you are not happy with the configuration possibilities, you can use callback functions. These functions are just like other configuration variables except that the values are actual functions.
</p>

<p>
	These tools provide both the <samp>onBefore</samp> event which occurs before some action is taken and the <samp>on</samp> event that occurs by the time (or after) an action takes place. You can have custom functionality bound to these events. All tools provide such events and they share a common naming policy. The <samp>onBefore</samp> event provides you with the possibility of cancelling the action
</p>

<h3>Callback example</h3>

<p>
	This example demonstrates the <samp>onBeforeClick</samp> callback function for tools.tabs.
</p>

<pii:code>
$("#example").tabs(".panes > div", {

	// here is a "normal" configuration variable
	current: 'active,

	// here is a callback function that is called before the tab is clicked
	onBeforeClick: function(event, tabIndex) {

		// the "this variable is a pointer to the API. You can do a lot with it.
		var tabPanes = this.getPanes();

		/*
			By returning false here the default behaviour is cancelled.
			This time another tab cannot be clicked when "terms" are not accepted
		*/
		return $(":checkbox[name=terms]").is(":checked");
	}

});
</pii:code>

<p>
	In every callback function the <samp>this</samp> variable is a reference to the programming API of the tool. In the above example this is a reference to the <a href="${jqt}/tabs.html#">Tabs API</a>. Again, this is what average programmers are used to and the tools follow this standard programming practice.
</p>

<h3>Multiple callback functions</h3>

<p>
	In the above example, we supplied our callback function in the configuration when the tool was initialized. You can supply callback functions from the the API as well. In fact, you can supply multiple callback functions for the same event this way. For example, you may have multiple <samp>onBeforeClick</samp> listeners which are all triggered when a tab is clicked. Here is an example of registering callbacks with the API:
</p>

<pii:code>
// get handle to the API. We assume that tabs have already been constructed
var api = $("#example").tabs();

// register a callback function
api.onBeforeClick(function(e, tabIndex) {

	// .. do your thing ..

});
</pii:code>

<p>
	Again, inside the callback function the <samp>this</samp> variable is a pointer to the programming API.
<p>

<a name="event_object"></a>
<h3>The Event object</h3>

<p>
	Since version 1.1.1. every supplied callback function receives the <a href="http://api.jquery.com/category/events/event-object/" class="external">jQuery.Event</a> object as the first argument for the callback function. This event object standardizes the event processing according to the <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow-cancelation" class="external">W3C standards</a>. Here are some things you can do with this object:
</p>

<pii:code>
// the event object is the first argument for *all* callbacks in jQuery Tools
api.onClick(function(event) {

	// cancel the default action. same as returning false
	event.preventDefault();

	/* If you have multiple callbacks of the same type this prevents
		the rest of the callbacks from being executed. */
	event.stopImmediatePropagation();

	// retrieve the value returned by the previous callback function
	event.result;

	// The timestamp (in milliseconds) of when the event was created.
	event.timeStamp;

	/*** the following properties were added in version 1.1.2 ***/

	// mouse position when event was fired
	var x = event.pageX;
	var y = event.pageY;

	// whether CTRL, ALT, SHIFT or ESC was being pressed
	var alt = event.altKey,
		 ctrl = event.ctrlKey,
		 shift = event.shiftMey,
		 esc = event.metaKey;


	// the original triggering element
	var element = e.originalTarget || e.srcElement;
});
</pii:code>

<p>
 	Within the scope of jQuery Tools, the <samp>preventDefault()</samp> is identical to returning <samp>false</samp> from the callback. This is just a matter of style where the <samp>preventDefault()</samp> is the modern manner of cancelling.
</p>

<p>
	You can get the handle to the actual element that fired the event with <samp>var element = e.originalTarget || e.srcElement;</samp>. For example, you can get a handle to the scrollable navigator item that was clicked inside the <samp>onSeek</samp> event.
</p>

<h3>Removing callbacks</h3>

<p>
	Sometimes you want to remove your callback function from being used. This can be done with the <samp>unbind</samp> call. Here is an example:
</p>

<pii:code>
// remove *all* user supplied onClick callbacks from the tool
api.unbind("onClick");
</pii:code>

<p>
	If you want to remove only a certain callback, you need to specify the callback for the tool with a custom name. This can be done with the <samp>bind</samp> function as follows:
</p>

<pii:code>
// supply a callback function with a custom name
api.bind("onClick.myname", function() {

});
</pii:code>

<p>
	Now this particular callback can be removed as follows:
</p>

<pii:code>
api.unbind("onClick.myname");
</pii:code>

<p>
	Since jQuery Tools 1.1.1. The <samp>bind</samp> and <samp>unbind</samp> methods are available for every tool.
</p>

<h3>Same callback for multiple events</h3>

<p>
	You can use the <samp>bind</samp> function to supply the same callback function for different events. For example:
</p>

<pii:code>
// bind a custom callback for both onLoad and onClose events of the Overlay tool
$("#myTrigger").overlay({api: true}).bind("onLoad onClose", function(event) {

	// know which event is being called by using the <samp>type</samp> property of the event object
	if (event.type == 'onLoad) {

	}

});
</pii:code>

<p>
 	The names of the events are separated by spaces. You can also supply a custom name for each of the callbacks such as <samp>onLoad.my onClose.my</samp>. You can use the <samp>unbind</samp> method to remove all callbacks at the same time by calling <samp>unbind()</samp>. In the case of the previous example you would do so by calling <samp>unbind(".my")</samp>.
</p>

<p style="font-weight:bold">
	Please note that the event object, <samp>unbind</samp> and <samp>bind</samp> methods are for experienced scripters only. An average user will most probably never use them.
</p>

<h3>A quick comparison with class-based inheritance</h3>

<p>
	Some programmers may argue that a better solution would have been to implement "classes" that users can "extend". Trust me, it's not. JavaScript is an inherently functional language, not an object-oriented one. Trying to mimic classical inherintance leads to poor design and makes programs longer and harder to understand. This is especially important in jQuery development because this library itself is highly dependent on callbacks and does not support any kind of inheritance. Functions are an easy, light-weight and effective way of extending behavior. Even newcomers can use them without understanding the anatomy of the JavaScript language.
</p>

<!--}}}-->


<!--{{{ Plugins -->

<a name="plugins"></a>
<h2>Creating jQuery Tools <em>Plugins</em></h2>

<p>
	It is possible to implement jQuery plugins that are tightly integrated with jQuery Tools. These plugins would typically alter the default behaviour of the tool or they can add new functionality.  jQuery Tools plugins are authored just like normal jQuery plugins with the exception that inside your plugin you'll get a handle to the Tools programming API and possibly supply callback functions. The fact that the tools can have an unlimited number of callback functions registered is the backbone of plugin development. Here is a simple skeleton for a plugin that will track Google Analytics each time a tab is clicked:
</p>

<pii:code>
// create jQuery plugin called "analytics"
$.fn.analytics = function(tracker) {

	// loop through each tab and enable analytics
	return this.each(function() {

		// get handle to tabs API.
		var api = $(this).tabs();

		// setup onClick listener for tabs
		api.onClick(function(index)  {
			tracker.trackEvent("tabs", "foo", index);
		});

	});
};
</pii:code>

<p>
	After you have this plugin included on your page, you can use the plugin in the following manner:
</p>

<pii:code>
// initialize tabs and the analytics plugin. the Analytics tracker argument is defined elsewhere
$("ul.tabs").tabs("div.panes > div").analytics(tracker);
</pii:code>

<p>
	If you are a jQuery plugin developer, you can see that this follows the "standard" way of developing plugins. The interesting part is the retrieval of API with the <samp>var api = $(this).tabs();</samp> command. Instead of constructing new tabs, it will return the API. This is because tabs were already constructed. In fact our previous setup <em>requires</em> that the tabs are initialized before the analytics plugin, so you <strong>cannot</strong> write:
</p>

<pii:code>
// this is wrong. the analytics plugin does not get access to the tabs API
$("ul.tabs").analytics(tracker).tabs("div.panes > div");
</pii:code>

<p>
	Here is a solid example about <a href="http://www.learningjquery.com/2007/10/a-plugin-development-pattern" class="external">developing jQuery plugins</a>. There are many plugins available on the <a href="download.html">download page</a>. You can take a look at their commented source code to get more understanding about the plugin development.
</p>

<!--}}}-->


<!--{{{ other libraries -->
<a name="other_libraries"></a>
<h2>Using the Tools with other plugins and libraries</h2>

<p>
	jQuery Tools can be used together with other libraries and plugins. Both jQuery and non-jQuery libraries can be included on the page and they should work together. The only thing that may cause problems is that you cannot use jQuery plugins that have the same name. You cannot, for example, use jQuery UI tabs together with jQuery Tools tabs since both are using the same name. But you can use any other UI widget without problems. The same is true for any other jQuery plugin you can find.
</p>

<p>
	If you are using other JavaScript libraries such as <a href="http://www.mootools.net" class="external">MooTools</a>, <a href="http://www.extjs.com" class="external">Ext JS</a> or <a href="http://www.prototypejs.org" class="external">Prototype</a> together with the Tools, then you can be even less worried about name conflicts. If your non-jQuery library uses the dollar sign <samp>$</samp> as the prefix (or namespace) for the plugin names, then you should look at jQuery's possibility to <a href="http://docs.jquery.com/Using_jQuery_with_Other_Libraries" class="external">override the $- function.</a>. jQuery Tools supports the switching of this namespace.
</p>



<!--}}}-->


